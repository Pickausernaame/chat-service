// Code generated by MockGen. DO NOT EDIT.
// Source: usecase.go

// Package getassignedproblemsmocks is a generated GoMock package.
package getassignedproblemsmocks

import (
	context "context"
	reflect "reflect"

	problemsrepo "github.com/Pickausernaame/chat-service/internal/repositories/problems"
	types "github.com/Pickausernaame/chat-service/internal/types"
	gomock "github.com/golang/mock/gomock"
)

// MockproblemRepository is a mock of problemRepository interface.
type MockproblemRepository struct {
	ctrl     *gomock.Controller
	recorder *MockproblemRepositoryMockRecorder
}

// MockproblemRepositoryMockRecorder is the mock recorder for MockproblemRepository.
type MockproblemRepositoryMockRecorder struct {
	mock *MockproblemRepository
}

// NewMockproblemRepository creates a new mock instance.
func NewMockproblemRepository(ctrl *gomock.Controller) *MockproblemRepository {
	mock := &MockproblemRepository{ctrl: ctrl}
	mock.recorder = &MockproblemRepositoryMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockproblemRepository) EXPECT() *MockproblemRepositoryMockRecorder {
	return m.recorder
}

// GetAssignedUnsolvedProblems mocks base method.
func (m *MockproblemRepository) GetAssignedUnsolvedProblems(ctx context.Context, managerID types.UserID) ([]*problemsrepo.ProblemAndClientID, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetAssignedUnsolvedProblems", ctx, managerID)
	ret0, _ := ret[0].([]*problemsrepo.ProblemAndClientID)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetAssignedUnsolvedProblems indicates an expected call of GetAssignedUnsolvedProblems.
func (mr *MockproblemRepositoryMockRecorder) GetAssignedUnsolvedProblems(ctx, managerID interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetAssignedUnsolvedProblems", reflect.TypeOf((*MockproblemRepository)(nil).GetAssignedUnsolvedProblems), ctx, managerID)
}

// MockchatRepository is a mock of chatRepository interface.
type MockchatRepository struct {
	ctrl     *gomock.Controller
	recorder *MockchatRepositoryMockRecorder
}

// MockchatRepositoryMockRecorder is the mock recorder for MockchatRepository.
type MockchatRepositoryMockRecorder struct {
	mock *MockchatRepository
}

// NewMockchatRepository creates a new mock instance.
func NewMockchatRepository(ctrl *gomock.Controller) *MockchatRepository {
	mock := &MockchatRepository{ctrl: ctrl}
	mock.recorder = &MockchatRepositoryMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockchatRepository) EXPECT() *MockchatRepositoryMockRecorder {
	return m.recorder
}

// ClientIDByID mocks base method.
func (m *MockchatRepository) ClientIDByID(ctx context.Context, id types.ChatID) (types.UserID, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ClientIDByID", ctx, id)
	ret0, _ := ret[0].(types.UserID)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ClientIDByID indicates an expected call of ClientIDByID.
func (mr *MockchatRepositoryMockRecorder) ClientIDByID(ctx, id interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ClientIDByID", reflect.TypeOf((*MockchatRepository)(nil).ClientIDByID), ctx, id)
}
